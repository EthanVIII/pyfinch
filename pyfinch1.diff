From a433eb45f8c932f8281c4c1b16c6c0866f1dbd00 Mon Sep 17 00:00:00 2001
From: Arthur Lee <arthur@example.com>
Date: Mon, 14 Feb 2022 03:36:33 +0800
Subject: [PATCH] Added poetry to manage project

---
 poetry.lock     | 149 ++++++++++++++++++++++++++++++++++++++++++++++++
 pyproject.toml  |  16 ++++++
 src/__init__.py |   0
 3 files changed, 165 insertions(+)
 create mode 100644 poetry.lock
 create mode 100644 pyproject.toml
 create mode 100644 src/__init__.py

diff --git a/poetry.lock b/poetry.lock
new file mode 100644
index 0000000..14724fe
--- /dev/null
+++ b/poetry.lock
@@ -0,0 +1,149 @@
+[[package]]
+name = "black"
+version = "22.1.0"
+description = "The uncompromising code formatter."
+category = "dev"
+optional = false
+python-versions = ">=3.6.2"
+
+[package.dependencies]
+click = ">=8.0.0"
+mypy-extensions = ">=0.4.3"
+pathspec = ">=0.9.0"
+platformdirs = ">=2"
+tomli = ">=1.1.0"
+
+[package.extras]
+colorama = ["colorama (>=0.4.3)"]
+d = ["aiohttp (>=3.7.4)"]
+jupyter = ["ipython (>=7.8.0)", "tokenize-rt (>=3.2.0)"]
+uvloop = ["uvloop (>=0.15.2)"]
+
+[[package]]
+name = "click"
+version = "8.0.3"
+description = "Composable command line interface toolkit"
+category = "dev"
+optional = false
+python-versions = ">=3.6"
+
+[package.dependencies]
+colorama = {version = "*", markers = "platform_system == \"Windows\""}
+
+[[package]]
+name = "colorama"
+version = "0.4.4"
+description = "Cross-platform colored terminal text."
+category = "dev"
+optional = false
+python-versions = ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*"
+
+[[package]]
+name = "isort"
+version = "5.10.1"
+description = "A Python utility / library to sort Python imports."
+category = "dev"
+optional = false
+python-versions = ">=3.6.1,<4.0"
+
+[package.extras]
+pipfile_deprecated_finder = ["pipreqs", "requirementslib"]
+requirements_deprecated_finder = ["pipreqs", "pip-api"]
+colors = ["colorama (>=0.4.3,<0.5.0)"]
+plugins = ["setuptools"]
+
+[[package]]
+name = "mypy-extensions"
+version = "0.4.3"
+description = "Experimental type system extensions for programs checked with the mypy typechecker."
+category = "dev"
+optional = false
+python-versions = "*"
+
+[[package]]
+name = "pathspec"
+version = "0.9.0"
+description = "Utility library for gitignore style pattern matching of file paths."
+category = "dev"
+optional = false
+python-versions = "!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,>=2.7"
+
+[[package]]
+name = "platformdirs"
+version = "2.5.0"
+description = "A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\"."
+category = "dev"
+optional = false
+python-versions = ">=3.7"
+
+[package.extras]
+docs = ["Sphinx (>=4)", "furo (>=2021.7.5b38)", "proselint (>=0.10.2)", "sphinx-autodoc-typehints (>=1.12)"]
+test = ["appdirs (==1.4.4)", "pytest (>=6)", "pytest-cov (>=2.7)", "pytest-mock (>=3.6)"]
+
+[[package]]
+name = "tomli"
+version = "2.0.1"
+description = "A lil' TOML parser"
+category = "dev"
+optional = false
+python-versions = ">=3.7"
+
+[metadata]
+lock-version = "1.1"
+python-versions = "^3.10"
+content-hash = "8e060c73e2b515cbcf13e1060b802fcbcd42e0b8548bfb8180cf967bb833575b"
+
+[metadata.files]
+black = [
+    {file = "black-22.1.0-cp310-cp310-macosx_10_9_universal2.whl", hash = "sha256:1297c63b9e1b96a3d0da2d85d11cd9bf8664251fd69ddac068b98dc4f34f73b6"},
+    {file = "black-22.1.0-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:2ff96450d3ad9ea499fc4c60e425a1439c2120cbbc1ab959ff20f7c76ec7e866"},
+    {file = "black-22.1.0-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:0e21e1f1efa65a50e3960edd068b6ae6d64ad6235bd8bfea116a03b21836af71"},
+    {file = "black-22.1.0-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:e2f69158a7d120fd641d1fa9a921d898e20d52e44a74a6fbbcc570a62a6bc8ab"},
+    {file = "black-22.1.0-cp310-cp310-win_amd64.whl", hash = "sha256:228b5ae2c8e3d6227e4bde5920d2fc66cc3400fde7bcc74f480cb07ef0b570d5"},
+    {file = "black-22.1.0-cp36-cp36m-macosx_10_9_x86_64.whl", hash = "sha256:b1a5ed73ab4c482208d20434f700d514f66ffe2840f63a6252ecc43a9bc77e8a"},
+    {file = "black-22.1.0-cp36-cp36m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:35944b7100af4a985abfcaa860b06af15590deb1f392f06c8683b4381e8eeaf0"},
+    {file = "black-22.1.0-cp36-cp36m-win_amd64.whl", hash = "sha256:7835fee5238fc0a0baf6c9268fb816b5f5cd9b8793423a75e8cd663c48d073ba"},
+    {file = "black-22.1.0-cp37-cp37m-macosx_10_9_x86_64.whl", hash = "sha256:dae63f2dbf82882fa3b2a3c49c32bffe144970a573cd68d247af6560fc493ae1"},
+    {file = "black-22.1.0-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:5fa1db02410b1924b6749c245ab38d30621564e658297484952f3d8a39fce7e8"},
+    {file = "black-22.1.0-cp37-cp37m-win_amd64.whl", hash = "sha256:c8226f50b8c34a14608b848dc23a46e5d08397d009446353dad45e04af0c8e28"},
+    {file = "black-22.1.0-cp38-cp38-macosx_10_9_universal2.whl", hash = "sha256:2d6f331c02f0f40aa51a22e479c8209d37fcd520c77721c034517d44eecf5912"},
+    {file = "black-22.1.0-cp38-cp38-macosx_10_9_x86_64.whl", hash = "sha256:742ce9af3086e5bd07e58c8feb09dbb2b047b7f566eb5f5bc63fd455814979f3"},
+    {file = "black-22.1.0-cp38-cp38-macosx_11_0_arm64.whl", hash = "sha256:fdb8754b453fb15fad3f72cd9cad3e16776f0964d67cf30ebcbf10327a3777a3"},
+    {file = "black-22.1.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:f5660feab44c2e3cb24b2419b998846cbb01c23c7fe645fee45087efa3da2d61"},
+    {file = "black-22.1.0-cp38-cp38-win_amd64.whl", hash = "sha256:6f2f01381f91c1efb1451998bd65a129b3ed6f64f79663a55fe0e9b74a5f81fd"},
+    {file = "black-22.1.0-cp39-cp39-macosx_10_9_universal2.whl", hash = "sha256:efbadd9b52c060a8fc3b9658744091cb33c31f830b3f074422ed27bad2b18e8f"},
+    {file = "black-22.1.0-cp39-cp39-macosx_10_9_x86_64.whl", hash = "sha256:8871fcb4b447206904932b54b567923e5be802b9b19b744fdff092bd2f3118d0"},
+    {file = "black-22.1.0-cp39-cp39-macosx_11_0_arm64.whl", hash = "sha256:ccad888050f5393f0d6029deea2a33e5ae371fd182a697313bdbd835d3edaf9c"},
+    {file = "black-22.1.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:07e5c049442d7ca1a2fc273c79d1aecbbf1bc858f62e8184abe1ad175c4f7cc2"},
+    {file = "black-22.1.0-cp39-cp39-win_amd64.whl", hash = "sha256:373922fc66676133ddc3e754e4509196a8c392fec3f5ca4486673e685a421321"},
+    {file = "black-22.1.0-py3-none-any.whl", hash = "sha256:3524739d76b6b3ed1132422bf9d82123cd1705086723bc3e235ca39fd21c667d"},
+    {file = "black-22.1.0.tar.gz", hash = "sha256:a7c0192d35635f6fc1174be575cb7915e92e5dd629ee79fdaf0dcfa41a80afb5"},
+]
+click = [
+    {file = "click-8.0.3-py3-none-any.whl", hash = "sha256:353f466495adaeb40b6b5f592f9f91cb22372351c84caeb068132442a4518ef3"},
+    {file = "click-8.0.3.tar.gz", hash = "sha256:410e932b050f5eed773c4cda94de75971c89cdb3155a72a0831139a79e5ecb5b"},
+]
+colorama = [
+    {file = "colorama-0.4.4-py2.py3-none-any.whl", hash = "sha256:9f47eda37229f68eee03b24b9748937c7dc3868f906e8ba69fbcbdd3bc5dc3e2"},
+    {file = "colorama-0.4.4.tar.gz", hash = "sha256:5941b2b48a20143d2267e95b1c2a7603ce057ee39fd88e7329b0c292aa16869b"},
+]
+isort = [
+    {file = "isort-5.10.1-py3-none-any.whl", hash = "sha256:6f62d78e2f89b4500b080fe3a81690850cd254227f27f75c3a0c491a1f351ba7"},
+    {file = "isort-5.10.1.tar.gz", hash = "sha256:e8443a5e7a020e9d7f97f1d7d9cd17c88bcb3bc7e218bf9cf5095fe550be2951"},
+]
+mypy-extensions = [
+    {file = "mypy_extensions-0.4.3-py2.py3-none-any.whl", hash = "sha256:090fedd75945a69ae91ce1303b5824f428daf5a028d2f6ab8a299250a846f15d"},
+    {file = "mypy_extensions-0.4.3.tar.gz", hash = "sha256:2d82818f5bb3e369420cb3c4060a7970edba416647068eb4c5343488a6c604a8"},
+]
+pathspec = [
+    {file = "pathspec-0.9.0-py2.py3-none-any.whl", hash = "sha256:7d15c4ddb0b5c802d161efc417ec1a2558ea2653c2e8ad9c19098201dc1c993a"},
+    {file = "pathspec-0.9.0.tar.gz", hash = "sha256:e564499435a2673d586f6b2130bb5b95f04a3ba06f81b8f895b651a3c76aabb1"},
+]
+platformdirs = [
+    {file = "platformdirs-2.5.0-py3-none-any.whl", hash = "sha256:30671902352e97b1eafd74ade8e4a694782bd3471685e78c32d0fdfd3aa7e7bb"},
+    {file = "platformdirs-2.5.0.tar.gz", hash = "sha256:8ec11dfba28ecc0715eb5fb0147a87b1bf325f349f3da9aab2cd6b50b96b692b"},
+]
+tomli = [
+    {file = "tomli-2.0.1-py3-none-any.whl", hash = "sha256:939de3e7a6161af0c887ef91b7d41a53e7c5a1ca976325f429cb46ea9bc30ecc"},
+    {file = "tomli-2.0.1.tar.gz", hash = "sha256:de526c12914f0c550d15924c62d72abc48d6fe7364aa87328337a31007fe8a4f"},
+]
diff --git a/pyproject.toml b/pyproject.toml
new file mode 100644
index 0000000..4c54b45
--- /dev/null
+++ b/pyproject.toml
@@ -0,0 +1,16 @@
+[tool.poetry]
+name = "pyfinch"
+version = "0.1.0"
+description = ""
+authors = ["Ethan <ethan@example.com>"]
+
+[tool.poetry.dependencies]
+python = "^3.10"
+
+[tool.poetry.dev-dependencies]
+black = "^22.1.0"
+isort = "^5.10.1"
+
+[build-system]
+requires = ["poetry-core>=1.0.0"]
+build-backend = "poetry.core.masonry.api"
diff --git a/src/__init__.py b/src/__init__.py
new file mode 100644
index 0000000..e69de29
-- 
2.34.1.windows.1

From 5fe2cf1485f97f35bc538740eb9090b035ad755e Mon Sep 17 00:00:00 2001
From: Arthur Lee <arthur@example.com>
Date: Mon, 14 Feb 2022 03:50:31 +0800
Subject: [PATCH] Formatted with isort and black

---
 src/aviary.py       |  22 +++++--
 src/bytedict.py     |  54 ++++++++++------
 src/finch.py        |  18 +++---
 src/lexome.py       | 146 +++++++++++++++++++++++++++++++-------------
 src/preprocessor.py |  95 ++++++++++++++++++----------
 src/terminal.py     |  61 ++++++++++--------
 src/visual.py       |  34 +++++++----
 7 files changed, 282 insertions(+), 148 deletions(-)

diff --git a/src/aviary.py b/src/aviary.py
index a16db3a..5af0331 100644
--- a/src/aviary.py
+++ b/src/aviary.py
@@ -1,7 +1,15 @@
 from finch import Finch
 from lexome import *
 
-def run_aviary(binary_lexome: list[bytearray], org_pops: list[int],binary_inst: bytearray, binary_dict: dict, str_dict: dict, size: int) -> None:
+
+def run_aviary(
+    binary_lexome: list[bytearray],
+    org_pops: list[int],
+    binary_inst: bytearray,
+    binary_dict: dict,
+    str_dict: dict,
+    size: int,
+) -> None:
     # binary_dict   Key:lexemes Val:binary
     # str_dict      Key:binary  Val:lexemes
     finches: list[Finch] = []
@@ -9,20 +17,22 @@ def run_aviary(binary_lexome: list[bytearray], org_pops: list[int],binary_inst:
     for index, l in enumerate(binary_lexome):
         for i in range(org_pops[index]):
             finches.append(Finch(l))
-    pretty("INFO","Innoculated with starting Pop")
-    pretty("INFO","Running Simulation...")
+    pretty("INFO", "Innoculated with starting Pop")
+    pretty("INFO", "Running Simulation...")
     for i in range(10):
         for finch in finches:
             if finch.skip_next_op:
                 finch.inc()
                 finch.skip_next_op = False
             else:
-                run_op(str_dict,finch)
+                run_op(str_dict, finch)
         print("Pop: {}".format(str(len(finches))))
-    pretty("INFO","Completed Simulation")
+    pretty("INFO", "Completed Simulation")
+
 
 def replication_queue() -> None:
     pass
 
+
 def mutation() -> None:
-    pass
\ No newline at end of file
+    pass
diff --git a/src/bytedict.py b/src/bytedict.py
index 27373e7..3d11183 100644
--- a/src/bytedict.py
+++ b/src/bytedict.py
@@ -1,5 +1,6 @@
 from visual import pretty
 
+
 # Generates byte dictionary per running instance.
 def to_dict(lexomes: list[str]) -> dict:
     inc_int: int = 0
@@ -7,9 +8,12 @@ def to_dict(lexomes: list[str]) -> dict:
     lexome_clean: list[str] = list(set(lexomes))
     ret_dict: dict = dict()
     try:
-        f = open("config\master_lexome.cfg",'r',encoding="utf-8")
+        f = open("config\master_lexome.cfg", "r", encoding="utf-8")
     except:
-        pretty("PANIC","master_lexome.cfg was not found in the config subfolder. Unable to parse master instruction set.")
+        pretty(
+            "PANIC",
+            "master_lexome.cfg was not found in the config subfolder. Unable to parse master instruction set.",
+        )
     lines: list[str] = f.readlines()
     f.close()
     for l in lines:
@@ -19,14 +23,20 @@ def to_dict(lexomes: list[str]) -> dict:
 
     for l in lexome_clean:
         if l not in master_lexome:
-            pretty("PANIC", "Instruction set contains implemented operation ({}). Unable to parse master instruction set.".format(l))
-        ret_dict[l] = inc_int.to_bytes(1,'big')
+            pretty(
+                "PANIC",
+                "Instruction set contains implemented operation ({}). Unable to parse master instruction set.".format(
+                    l
+                ),
+            )
+        ret_dict[l] = inc_int.to_bytes(1, "big")
         inc_int += 1
     if len(lexomes) != len(lexome_clean):
         pretty("WARNING", "Instruction set contains duplicate instructions")
-    pretty("INFO","Validated INST set")
+    pretty("INFO", "Validated INST set")
     return ret_dict
 
+
 # Converts lexome set to binary dictionary.
 # Also does some checking to ensure that instruction set is a subset of all master operations.
 def to_dict(lexomes: list[str]) -> list[bytearray]:
@@ -35,9 +45,12 @@ def to_dict(lexomes: list[str]) -> list[bytearray]:
     lexome_clean: list[str] = list(set(lexomes))
     ret_dict: dict = dict()
     try:
-        f = open("config\master_lexome.cfg",'r',encoding="utf-8")
+        f = open("config\master_lexome.cfg", "r", encoding="utf-8")
     except:
-        pretty("PANIC","master_lexome.cfg was not found in the config subfolder. Unable to parse master instruction set.")
+        pretty(
+            "PANIC",
+            "master_lexome.cfg was not found in the config subfolder. Unable to parse master instruction set.",
+        )
     lines: list[str] = f.readlines()
     f.close()
     for l in lines:
@@ -47,31 +60,34 @@ def to_dict(lexomes: list[str]) -> list[bytearray]:
 
     for l in lexome_clean:
         if l not in master_lexome:
-            pretty("PANIC", "Instruction set contains implemented operation ({}). Unable to parse master instruction set.".format(l))
-        ret_dict[l] = inc_int.to_bytes(1,'big')
+            pretty(
+                "PANIC",
+                "Instruction set contains implemented operation ({}). Unable to parse master instruction set.".format(
+                    l
+                ),
+            )
+        ret_dict[l] = inc_int.to_bytes(1, "big")
         inc_int += 1
     if len(lexomes) != len(lexome_clean):
-        
+
         pretty("WARNING", "Instruction set contains duplicate instructions")
-    pretty("INFO","Validated lexome sets")
+    pretty("INFO", "Validated lexome sets")
 
-    pretty("INFO","Loaded binary dictionary")
+    pretty("INFO", "Loaded binary dictionary")
     return ret_dict
 
+
 # Using a provided dictionary, translates a lexome to bytearrays.
-def translate_to_bytes(org: list[str],l_dict: dict) -> bytearray:
+def translate_to_bytes(org: list[str], l_dict: dict) -> bytearray:
     ret_bytes: bytearray = bytearray()
     for o in org:
         ret_bytes.extend(l_dict[o])
     return ret_bytes
 
+
 # Using a provided dictionary, translates a bytearray to lexome.
-def translate_to_str(org: bytearray,l_dict: dict) -> list[str]:
+def translate_to_str(org: bytearray, l_dict: dict) -> list[str]:
     ret_list: list[str] = []
     for x in org:
-        ret_list.append(l_dict[x.to_bytes(1,'big')])
+        ret_list.append(l_dict[x.to_bytes(1, "big")])
     return ret_list
-
-
-
-    
diff --git a/src/finch.py b/src/finch.py
index 77251f7..edf062c 100644
--- a/src/finch.py
+++ b/src/finch.py
@@ -1,27 +1,27 @@
 class Finch:
-    def __init__(self,lexome: bytearray) -> None:
+    def __init__(self, lexome: bytearray) -> None:
         # Components - CPU, Memory, Output
-        i32_BA: bytearray = bytearray((0).to_bytes(4,'big'))
+        i32_BA: bytearray = bytearray((0).to_bytes(4, "big"))
         self.lexome = lexome
         self.register: list[bytearray] = [i32_BA.copy() for i in range(3)]
-        self.stacks: list[list[bytearray]] = [[],[]]
+        self.stacks: list[list[bytearray]] = [[], []]
         self.active: int = 0
         self.s1: list[bytearray] = []
         self.s2: list[bytearray] = []
         self.read_h: int = 0
         self.writ_h: int = 0
-        self.flow_h: int = 0 
+        self.flow_h: int = 0
         self.inst_h: int = 0
         self.input: list[bytearray] = [i32_BA.copy() for i in range(3)]
         self.output: bytearray = i32_BA.copy()
-        
+
         # Attributes
         self.age: int = 0
         self.skip_next_op: bool = False
 
         # C
         del i32_BA
-    
+
     # Increments the instruction head for the next cycle.
     # Lexome is a loop.
     def inc(self) -> None:
@@ -39,11 +39,11 @@ class Finch:
         buffer: list[str] = []
         buffer.append("-----\n")
         buffer.append("aX: ")
-        buffer.append(str(int.from_bytes(self.register[0],'big')))
+        buffer.append(str(int.from_bytes(self.register[0], "big")))
         buffer.append(" bX: ")
-        buffer.append(str(int.from_bytes(self.register[1],'big')))
+        buffer.append(str(int.from_bytes(self.register[1], "big")))
         buffer.append(" cX: ")
-        buffer.append(str(int.from_bytes(self.register[2],'big')))
+        buffer.append(str(int.from_bytes(self.register[2], "big")))
         buffer.append("\n")
         buffer.append("Stack 1: ")
         buffer.append(str(self.stacks[0]))
diff --git a/src/lexome.py b/src/lexome.py
index 6f690fd..337bc22 100644
--- a/src/lexome.py
+++ b/src/lexome.py
@@ -1,27 +1,37 @@
+import copy
+
 from finch import Finch
 from visual import pretty
-import copy
+
 
 def run_op(str_dict: dict, finch: Finch) -> str:
-    op: str = str_dict[finch.lexome[finch.inst_h].to_bytes(1,'big')]
-    exec(op +"(finch,str_dict)")
+    op: str = str_dict[finch.lexome[finch.inst_h].to_bytes(1, "big")]
+    exec(op + "(finch,str_dict)")
     return op
 
+
 def tinc(current: int, length: int, step=1) -> int:
-    if current+step >= length:
+    if current + step >= length:
         return current + step - length
     if current >= length:
-        pretty("WARNING","function tinc() in lexome.py has incremented a pointer > lexome.")
-    return current+step
+        pretty(
+            "WARNING",
+            "function tinc() in lexome.py has incremented a pointer > lexome.",
+        )
+    return current + step
+
 
 # Calculates the complement of the a-b-c label
 def comp(register: int) -> int:
     if register == 2:
-        return 0 
+        return 0
     return register + 1
 
+
 def next_nop(finch: Finch, str_dict: dict) -> int:
-    next_str: str = str_dict[finch.lexome[tinc(finch.inst_h, len(finch.lexome))].to_bytes(1,'big')]
+    next_str: str = str_dict[
+        finch.lexome[tinc(finch.inst_h, len(finch.lexome))].to_bytes(1, "big")
+    ]
     match next_str:
         case "nop_A":
             return 0
@@ -32,14 +42,20 @@ def next_nop(finch: Finch, str_dict: dict) -> int:
         case _:
             return 3
 
+
 # Instruction No-Ops
 def nop_B(finch: Finch, str_dict: dict) -> None:
     finch.inc()
+
+
 def nop_A(finch: Finch, str_dict: dict) -> None:
     finch.inc()
+
+
 def nop_C(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
+
 def if_n_equ(finch: Finch, str_dict: dict) -> None:
     # ?BX?
     reg: int = next_nop(finch, str_dict)
@@ -51,9 +67,10 @@ def if_n_equ(finch: Finch, str_dict: dict) -> None:
         finch.skip_next_op = False
     finch.inc()
 
+
 def if_less(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     if finch.register[reg] >= finch.register[comp(reg)]:
@@ -62,25 +79,28 @@ def if_less(finch: Finch, str_dict: dict) -> None:
         finch.skip_next_op = False
     finch.inc()
 
+
 def pop(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
-    element: bytearray = bytearray((0).to_bytes(4,'big'))
+    element: bytearray = bytearray((0).to_bytes(4, "big"))
     if finch.stacks[finch.active] != []:
         element = finch.stacks[finch.active][-1]
     finch.register[reg] = element
     finch.inc()
 
+
 def push(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.stacks[finch.active].append(finch.register[reg])
     finch.inc()
 
+
 def swap_stk(finch: Finch, str_dict: dict) -> None:
     if finch.active == 0:
         finch.active = 1
@@ -88,82 +108,116 @@ def swap_stk(finch: Finch, str_dict: dict) -> None:
         finch.active = 0
     finch.inc()
 
+
 def swap(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
-    finch.register[reg], finch.register[comp(reg)] = finch.register[comp(reg)], finch.register[reg]
+    finch.register[reg], finch.register[comp(reg)] = (
+        finch.register[comp(reg)],
+        finch.register[reg],
+    )
     finch.inc()
 
+
 def shift_r(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
-    finch.register[reg] = bytearray((int.from_bytes(finch.register[reg],'big') >> 1).to_bytes(4,'big'))
+    finch.register[reg] = bytearray(
+        (int.from_bytes(finch.register[reg], "big") >> 1).to_bytes(4, "big")
+    )
     finch.inc()
 
+
 def shift_l(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
-    finch.register[reg] = bytearray((int.from_bytes(finch.register[reg],'big') << 1).to_bytes(4,'big'))
+    finch.register[reg] = bytearray(
+        (int.from_bytes(finch.register[reg], "big") << 1).to_bytes(4, "big")
+    )
     finch.inc()
 
+
 def inc(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
-    finch.register[reg]  = bytearray((int.from_bytes(finch.register[reg],'big') + 1).to_bytes(4,'big'))
+    finch.register[reg] = bytearray(
+        (int.from_bytes(finch.register[reg], "big") + 1).to_bytes(4, "big")
+    )
     finch.inc()
 
+
 def dec(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
-    finch.register[reg]  = bytearray((int.from_bytes(finch.register[reg],'big') - 1).to_bytes(4,'big'))
+    finch.register[reg] = bytearray(
+        (int.from_bytes(finch.register[reg], "big") - 1).to_bytes(4, "big")
+    )
     finch.inc()
 
+
 def add(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
-    finch.register[reg] = bytearray(int.from_bytes(finch.register[1],'big') + int.from_bytes(finch.register[2],'big'))
+    finch.register[reg] = bytearray(
+        int.from_bytes(finch.register[1], "big")
+        + int.from_bytes(finch.register[2], "big")
+    )
     finch.inc()
 
+
 def sub(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
-        reg = 1 
-    finch.register[reg] = bytearray((int.from_bytes(finch.register[1],'big') - int.from_bytes(finch.register[2],'big')).to_bytes(4,'big'))
+        reg = 1
+    finch.register[reg] = bytearray(
+        (
+            int.from_bytes(finch.register[1], "big")
+            - int.from_bytes(finch.register[2], "big")
+        ).to_bytes(4, "big")
+    )
     finch.inc()
 
+
 def xor(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
-        reg = 1 
-    finch.register[reg] = bytearray((int.from_bytes(finch.register[1],'big') ^ int.from_bytes(finch.register[2],'big')).to_bytes(4,'big'))
+        reg = 1
+    finch.register[reg] = bytearray(
+        (
+            int.from_bytes(finch.register[1], "big")
+            ^ int.from_bytes(finch.register[2], "big")
+        ).to_bytes(4, "big")
+    )
     finch.inc()
 
+
 def io(finch: Finch, str_dict: dict) -> None:
     # ?BX?
-    reg: int = next_nop(finch,str_dict)
+    reg: int = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.output = copy.copy(finch.register[reg])
     finch.register[reg] = copy.copy(finch.input[0])
     finch.inc()
 
+
 def mov_head(finch: Finch, str_dict: dict) -> None:
     # ?IP?
-    head: int = next_nop(finch,str_dict)
+    head: int = next_nop(finch, str_dict)
     if head == 3:
         head = 0
     match head:
@@ -175,48 +229,56 @@ def mov_head(finch: Finch, str_dict: dict) -> None:
             finch.writ_h = copy.copy(finch.flow_h)
     finch.inc()
 
+
 def jmp_head(finch: Finch, str_dict: dict) -> None:
     # ?IP?
-    head: int = next_nop(finch,str_dict)
+    head: int = next_nop(finch, str_dict)
     if head == 3:
         head = 0
     match head:
         case 0:
-            finch.inst_h = tinc(finch.inst_h,len(finch.lexome),finch.register[2])
+            finch.inst_h = tinc(finch.inst_h, len(finch.lexome), finch.register[2])
         case 1:
-            finch.read_h = tinc(finch.read_h,len(finch.lexome),finch.register[2])
+            finch.read_h = tinc(finch.read_h, len(finch.lexome), finch.register[2])
         case 2:
-            finch.writ_h = tinc(finch.read_h,len(finch.lexome),finch.register[2])
-    finch.inc()   
+            finch.writ_h = tinc(finch.read_h, len(finch.lexome), finch.register[2])
+    finch.inc()
+
 
 def get_head(finch: Finch, str_dict: dict) -> None:
     # ?IP?
-    head: int = next_nop(finch,str_dict)
+    head: int = next_nop(finch, str_dict)
     if head == 3:
         head = 0
     match head:
         case 0:
-            finch.register[2] = bytearray(finch.inst_h.to_bytes(4,'big'))
+            finch.register[2] = bytearray(finch.inst_h.to_bytes(4, "big"))
         case 1:
-            finch.register[2] = bytearray(finch.read_h.to_bytes(4,'big'))
+            finch.register[2] = bytearray(finch.read_h.to_bytes(4, "big"))
         case 2:
-            finch.register[2] = bytearray(finch.writ_h.to_bytes(4,'big'))
+            finch.register[2] = bytearray(finch.writ_h.to_bytes(4, "big"))
     finch.inc()
 
+
 def h_alloc(finch: Finch, str_dict: dict) -> None:
     print("h_alloc - unimplemented")
 
+
 def h_divide(finch: Finch, str_dict: dict) -> None:
     print("h_divide - unimplemented")
 
+
 def h_copy(finch: Finch, str_dict: dict) -> None:
     print("h_copy - unimplemented")
 
+
 def h_search(finch: Finch, str_dict: dict) -> None:
     print("h_search - unimplemented")
 
+
 def if_label(finch: Finch, str_dict: dict) -> None:
     print("if_label - unimplemented")
 
+
 def set_flow(finch: Finch, str_dict: dict) -> None:
-    print("set_flow - unimplemented")
\ No newline at end of file
+    print("set_flow - unimplemented")
diff --git a/src/preprocessor.py b/src/preprocessor.py
index 369f9c1..a42924e 100644
--- a/src/preprocessor.py
+++ b/src/preprocessor.py
@@ -1,52 +1,67 @@
 from visual import pretty
 
-def pre_process() -> tuple[list[list[str]],list[str]]:
+
+def pre_process() -> tuple[list[list[str]], list[str]]:
     org_names: list[str] = []
     org_pops: list[int] = []
     lexome_name: str = ""
-    orgs, lexome = list[list[str]],list[str]
+    orgs, lexome = list[list[str]], list[str]
     orgs, lexome = [], []
     size: int = 0
 
     # Parses Config File Once and all at once.
-    org_names, org_pops,lexome_name, size = finch_parser("default")
-    pretty("INFO","Parsed PYFINCH config")
-    
+    org_names, org_pops, lexome_name, size = finch_parser("default")
+    pretty("INFO", "Parsed PYFINCH config")
+
     # Parses Lexome Set
     try:
-        f = open("lexome\{}.cfg".format(lexome_name),'r',encoding="utf-8") 
+        f = open("lexome\{}.cfg".format(lexome_name), "r", encoding="utf-8")
     except:
-        pretty("PANIC","{}.cfg was not found in lexome folder".format(lexome_name))
+        pretty("PANIC", "{}.cfg was not found in lexome folder".format(lexome_name))
     lines: list[str] = f.readlines()
     f.close()
     lexome = lexome_parser(lines)
-    pretty("INFO","Parsed lexome sets")
+    pretty("INFO", "Parsed lexome sets")
 
     # Parses Organism - Checks lexome for errors.
     for org_name in org_names:
-        try: 
-            f = open("org\{}.lxm".format(org_name),'r',encoding="utf-8")
+        try:
+            f = open("org\{}.lxm".format(org_name), "r", encoding="utf-8")
         except:
-            pretty("PANIC", "Specified organism lexome ({}.lxm) was not found in org folder".format(org_name))
+            pretty(
+                "PANIC",
+                "Specified organism lexome ({}.lxm) was not found in org folder".format(
+                    org_name
+                ),
+            )
         lines: list[str] = f.readlines()
         f.close()
         temp_org: list[str] = org_parser(lines)
         if len(temp_org) == 0:
-            pretty("WARNING","There is no lexome for this organism ({})".format(org_name))
-        result, offending = org_check(lexome,temp_org)
+            pretty(
+                "WARNING", "There is no lexome for this organism ({})".format(org_name)
+            )
+        result, offending = org_check(lexome, temp_org)
         if not result:
-            pretty("PANIC","The lexome for this organism ({}) contains Ops that are not a part of the Lexome Set ({})".format(org_name,offending))
+            pretty(
+                "PANIC",
+                "The lexome for this organism ({}) contains Ops that are not a part of the Lexome Set ({})".format(
+                    org_name, offending
+                ),
+            )
         orgs.append(temp_org)
     pretty("INFO", "Parsed organism lexomes")
-    return (orgs,org_pops,lexome,size)
+    return (orgs, org_pops, lexome, size)
+
 
 # Validates that organism org complies to the instruction set lexome_set
-def org_check(lexome_set: list[str],org: list[str]) -> tuple[bool, str]:
+def org_check(lexome_set: list[str], org: list[str]) -> tuple[bool, str]:
     for x in org:
         if x not in lexome_set:
             return (False, x)
     return (True, None)
 
+
 # Parses organism from lexome file (list of strings)
 def org_parser(ops: list[str]) -> list[str]:
     o_split: list[str] = []
@@ -54,32 +69,40 @@ def org_parser(ops: list[str]) -> list[str]:
     for o in ops:
         o_split = o.split("#")
         first_str: str = o_split[0].strip()
-        if first_str == '':
+        if first_str == "":
             continue
         org_intermediary.append(first_str)
     return org_intermediary
 
+
 # Parses lexome from file
 def lexome_parser(ops: list[str]) -> list[str]:
     o_split: list[str] = []
     lexome_intermediary: list[str] = []
     for o in ops:
         o_split += o.split(" ")
-    o_split = list(map(str.strip,filter(lambda x: x != "\n", o_split)))
+    o_split = list(map(str.strip, filter(lambda x: x != "\n", o_split)))
     for index, o in enumerate(o_split):
-        is_last: bool = (index+1) == len(o_split)
+        is_last: bool = (index + 1) == len(o_split)
         if o == "INST":
             if is_last:
-                pretty("PANIC", "Lexome config was formatted incorrectly. There are tailing tags present.")
-            if o_split[index+1] == "INST":
-                pretty("PANIC", "Lexome config was formatted incorrectly. There are back-to-back INST.")
-            lexome_intermediary.append(o_split[index+1])
+                pretty(
+                    "PANIC",
+                    "Lexome config was formatted incorrectly. There are tailing tags present.",
+                )
+            if o_split[index + 1] == "INST":
+                pretty(
+                    "PANIC",
+                    "Lexome config was formatted incorrectly. There are back-to-back INST.",
+                )
+            lexome_intermediary.append(o_split[index + 1])
     return lexome_intermediary
 
+
 # Parses and checks config file. File has to be in a subfolder config\default.cfg.
-def finch_parser(name: str) -> tuple[list[str],str,int]:
+def finch_parser(name: str) -> tuple[list[str], str, int]:
     try:
-        with open("config\{}.cfg".format(name),'r',encoding='utf-8') as f:
+        with open("config\{}.cfg".format(name), "r", encoding="utf-8") as f:
             lines: list[str] = f.readlines()
     except:
         pretty("PANIC", "Finch config was not found in config subfolder.")
@@ -87,10 +110,13 @@ def finch_parser(name: str) -> tuple[list[str],str,int]:
     lexome_name: str = ""
     org_pops: list[int] = []
     size: int = -1
-    for row, line in enumerate(lines):       
+    for row, line in enumerate(lines):
         entry: list[str] = line.split(" ")
-        if len(entry) == 1 and entry[0] != '\n':
-            pretty("PANIC", "Finch Config was formatted incorrectly. Blank fields were found.")
+        if len(entry) == 1 and entry[0] != "\n":
+            pretty(
+                "PANIC",
+                "Finch Config was formatted incorrectly. Blank fields were found.",
+            )
         match (entry[0]):
             case "\n":
                 pass
@@ -101,10 +127,15 @@ def finch_parser(name: str) -> tuple[list[str],str,int]:
             case "SIZE":
                 size = int(entry[1].strip())
             case "ORG":
-                org_names = list(map(str.strip,entry[1::2]))
-                org_pops  = list(map(int,list(map(str.strip,entry[2::2]))))
+                org_names = list(map(str.strip, entry[1::2]))
+                org_pops = list(map(int, list(map(str.strip, entry[2::2]))))
             case _:
-                pretty("PANIC","Finch Config contains unknown command in line {} and command {}".format(row,entry[0]))
+                pretty(
+                    "PANIC",
+                    "Finch Config contains unknown command in line {} and command {}".format(
+                        row, entry[0]
+                    ),
+                )
     if size == -1:
         pretty("PANIC", "Finch Config did not specify a valid aviary size.")
-    return (org_names,org_pops,lexome_name,size)
\ No newline at end of file
+    return (org_names, org_pops, lexome_name, size)
diff --git a/src/terminal.py b/src/terminal.py
index 8ba1862..d787dac 100644
--- a/src/terminal.py
+++ b/src/terminal.py
@@ -2,6 +2,7 @@ def main() -> None:
     os.chdir("..")
     runInterface()
 
+
 # Option to run the simulation
 def run_sim() -> None:
     pretty("SPRT", "Starting Pre-Processing & Parsing (IO)")
@@ -9,76 +10,82 @@ def run_sim() -> None:
     str_lexome: list[str] = []
     size: int = 0
     org_pops: list[int] = []
-    str_orgs,org_pops, str_lexome, size = preprocessor.pre_process()
+    str_orgs, org_pops, str_lexome, size = preprocessor.pre_process()
 
     # Converts lexemes to binary
     binary_dict: dict = bytedict.to_dict(str_lexome)
     # Converts binary to lexemes
-    str_dict: dict = dict(zip(binary_dict.values(),binary_dict.keys())) 
-
-    pretty("SPRT","Completed Pre-Processing & Parsing (IO)")
+    str_dict: dict = dict(zip(binary_dict.values(), binary_dict.keys()))
 
+    pretty("SPRT", "Completed Pre-Processing & Parsing (IO)")
 
     binary_orgs: list[bytearray] = []
     # Binary Lexome - will be used for mutation
-    binary_lexome: bytearray = bytedict.translate_to_bytes(str_lexome,binary_dict)
+    binary_lexome: bytearray = bytedict.translate_to_bytes(str_lexome, binary_dict)
 
     # Read string organisms and translate to binary.
     for o in str_orgs:
-        binary_orgs.append(bytedict.translate_to_bytes(o,binary_dict))
+        binary_orgs.append(bytedict.translate_to_bytes(o, binary_dict))
 
     print()
-    aviary.run_aviary(binary_orgs,org_pops, binary_lexome, binary_dict, str_dict, size)
+    aviary.run_aviary(binary_orgs, org_pops, binary_lexome, binary_dict, str_dict, size)
 
     quit()
 
+
 # Startup interface
 def runInterface() -> None:
     buffer: str = ""
-    title_buffer: str =  "-"*23 + "\n"
-    title_buffer +=      "PYFINCH - ALPHA BUILD\n"
-    title_buffer +=      "-"*23
-    for i, (option,_) in enumerate(optionHandler(get=True)):
-        buffer += "[" + str(i) +  "]: " + option + "\n"
+    title_buffer: str = "-" * 23 + "\n"
+    title_buffer += "PYFINCH - ALPHA BUILD\n"
+    title_buffer += "-" * 23
+    for i, (option, _) in enumerate(optionHandler(get=True)):
+        buffer += "[" + str(i) + "]: " + option + "\n"
     while True:
-        pretty("HEADER",title_buffer)
-        pretty("BOLD",buffer)
-        action: list[(str,str)] = optionHandler(input())
+        pretty("HEADER", title_buffer)
+        pretty("BOLD", buffer)
+        action: list[(str, str)] = optionHandler(input())
         if action[0][0] == "NOP":
             print("Invalid Action")
         else:
             exec(action[1])
 
+
 # Handles the display menus - easily updateable.
-def optionHandler(option: str = None, get: bool=False) -> list[(str,str)]:
-    options: list[(str,str)] = []
-    options.append(("Run Simulation - Run a preset simulation","run_sim()"))
-    options.append(("About - Information about PYFINCH","about()"))
-    options.append(("Quit - Quit PYFINCH","quit()"))
+def optionHandler(option: str = None, get: bool = False) -> list[(str, str)]:
+    options: list[(str, str)] = []
+    options.append(("Run Simulation - Run a preset simulation", "run_sim()"))
+    options.append(("About - Information about PYFINCH", "about()"))
+    options.append(("Quit - Quit PYFINCH", "quit()"))
     if get:
         return options
     try:
         choice: int = int(option)
     except:
-        return [("NOP","NOP")]
+        return [("NOP", "NOP")]
     if choice >= len(options) or choice < 0:
-        return [("NOP","NOP")]
+        return [("NOP", "NOP")]
     return options[choice]
 
+
 # Option to display About.
 def about() -> None:
     try:
-        with open("about.txt",'r',encoding='utf-8') as f:
+        with open("about.txt", "r", encoding="utf-8") as f:
             lines = f.read()
         print(lines)
     except:
-        pretty("WARNING","The file (about.txt) could not be found in top level directory")
+        pretty(
+            "WARNING", "The file (about.txt) could not be found in top level directory"
+        )
 
 
 if __name__ == "__main__":
-    import preprocessor
+    import os
+
     import aviary
     import bytedict
-    import os
+    import preprocessor
     from visual import pretty
-    main()
\ No newline at end of file
+
+    main()
diff --git a/src/visual.py b/src/visual.py
index 9c02179..fa03f30 100644
--- a/src/visual.py
+++ b/src/visual.py
@@ -1,15 +1,16 @@
 class col:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKCYAN = '\033[96m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
+    HEADER = "\033[95m"
+    OKBLUE = "\033[94m"
+    OKCYAN = "\033[96m"
+    OKGREEN = "\033[92m"
+    WARNING = "\033[93m"
+    FAIL = "\033[91m"
+    ENDC = "\033[0m"
+    BOLD = "\033[1m"
+    UNDERLINE = "\033[4m"
 
-def pretty(type:str, text:str) -> None:
+
+def pretty(type: str, text: str) -> None:
     b = col
     match type:
         case "INFO":
@@ -19,11 +20,18 @@ def pretty(type:str, text:str) -> None:
         case "WARNING":
             print(col.WARNING + "[WARNING] " + col.ENDC + text)
         case "PANIC":
-            print(col.FAIL + "[PANIC] " + text + col.ENDC )
+            print(col.FAIL + "[PANIC] " + text + col.ENDC)
             quit()
         case "BOLD":
             print(col.BOLD + text + col.BOLD)
         case "SPRT":
-            print(col.OKBLUE + "----- " + text + " -----" +col.ENDC)
+            print(col.OKBLUE + "----- " + text + " -----" + col.ENDC)
         case _:
-            print(col.WARNING + "[WARNING] " + col.ENDC + "No pretty format for: " + text[0:3] + "...")
+            print(
+                col.WARNING
+                + "[WARNING] "
+                + col.ENDC
+                + "No pretty format for: "
+                + text[0:3]
+                + "..."
+            )
-- 
2.34.1.windows.1

From f20ccf5478f2274340e5e54fc7bbc9eee7da915d Mon Sep 17 00:00:00 2001
From: Arthur Lee <arthur@example.com>
Date: Mon, 14 Feb 2022 04:26:22 +0800
Subject: [PATCH] Added __pycache__ to .gitignore to the temporary folder from
 repo

---
 .gitignore                                   |   1 +
 src/__pycache__/aviary.cpython-310.pyc       | Bin 1102 -> 0 bytes
 src/__pycache__/bytedict.cpython-310.pyc     | Bin 2050 -> 0 bytes
 src/__pycache__/finch.cpython-310.pyc        | Bin 1879 -> 0 bytes
 src/__pycache__/lexome.cpython-310.pyc       | Bin 6464 -> 0 bytes
 src/__pycache__/preprocessor.cpython-310.pyc | Bin 3502 -> 0 bytes
 src/__pycache__/visual.cpython-310.pyc       | Bin 1097 -> 0 bytes
 7 files changed, 1 insertion(+)
 create mode 100644 .gitignore
 delete mode 100644 src/__pycache__/aviary.cpython-310.pyc
 delete mode 100644 src/__pycache__/bytedict.cpython-310.pyc
 delete mode 100644 src/__pycache__/finch.cpython-310.pyc
 delete mode 100644 src/__pycache__/lexome.cpython-310.pyc
 delete mode 100644 src/__pycache__/preprocessor.cpython-310.pyc
 delete mode 100644 src/__pycache__/visual.cpython-310.pyc

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..61f2dc9
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+**/__pycache__/
diff --git a/src/__pycache__/aviary.cpython-310.pyc b/src/__pycache__/aviary.cpython-310.pyc
deleted file mode 100644
index f1ff902345bf369197fd4227f0bbb07f90b8be2d..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1102
zcmZ`&OK%e~5VrT7&4aWmQVSF!Zb2e9E)_yZErnh}Md1<!McdeI4ZGg0*9%S9oWc)j
zFG&3r{10C_^~?ovfthW@qXJ9wd1gKS#-4ATHk%=VvHLC9|7;WT1%p3F3xdaB`2c_s
zMq`rD0j20$vGtNLo7>!3Bg}!>h1ul}^SH-+uz<U)#=?UZtFy*OXW+9X)?_X40`RV}
zHh8eUN4m=wz)!l=xZ6UGkHDe#OmknzNKHmDKS>jAf>a%jvNX$0eX$^9u73qgjI{}J
ztwxpS<YLN=r?@VZ?2kR<UyM4;KG-H${t4ia%sfp>GN)VQ^~%ti`LjUNl9vA3<+s|b
zR(hwFw##5n&*1vU?PE_nj52F(QBrw!<x%ETEO&7Sur1HRGJNBzjWRs-&ImNlEyIy}
zd|&&eQ--(){D66<H67}D>CGutm}8A@#p`1ZBhaLvZ=9X}_Velbj+E)Rh$GEe=e^KJ
zom@vs3whYtO|$9s7lo7<?1==EL@Il|-UTYXJ@p}Dqw`@lUD-^NEaph@JFnX?H7<*U
zE8sS+isT_QG0HM7nX-Vucp0=*PX>+rt;j}_pXgDV4Qx<t;Hg4FVBAazsf~A#swC3J
z22G3|bJ?vc2Pl+_fPyGgK?MjkfPsI2;`7|NLNb10Xl$r3ZuRw?s5Qv>{$O)s_$ucr
zA3o7XksNM8BN8rkK71<lvtoakO{)B1uExXYoq!*xmrYEFXS)pX4Eb#U$8K9~+NRcz
z&<bgT2Gj!!Xv12iEvjxp${6ggK_SBb<}0$GD(AFc9qcOHfOWH^covIsCBf*p;00gB
zz1T>HDm=q~3#ePLs@4(k-dCZb50XMx+;~)V2cZMdwG?XI?}iG?Ep%JFA}1E`XlnZt
r%_F6vi2>=faq!JlH?B@q(fqsQ!z5)z%pYMRaxBvz0qt4gO3VHUqkIdT

diff --git a/src/__pycache__/bytedict.cpython-310.pyc b/src/__pycache__/bytedict.cpython-310.pyc
deleted file mode 100644
index 235f657824cd90ca15c176aae499a066c00e170d..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 2050
zcmds2TW=dh6rP#AJ9e6w7Lo|c0ut0k1jI`bsv@Galt{>}D5b)3W!5`mXT^Hgof(%T
ztR<xI%73sQ^OxociKp@hko?3s<CG??D#0tens4WF&Y5rKT()d9Y6KqjSJ;2FLdYLD
zIR6AN_yU^J0Gx1|lM(GuN;nftIGcn!!X3EW<=(Gu$2&L6guh8(#XnmK&g4Vkf{s7%
zdBkg=6YxOzd^u|^!paJ-!%D~-_epE@DeO#I)c9j5v_3LHE)L6)P{xPxL>4JUfwL!q
zuMcexn))4p(<vR2DbqyLik#3BI(0NVAyfA_(hg_bLGHgfQ|}=uB1-Vp$T~P-lzdMr
zZ|2R()Q7J>hqcPTMIK$A230T%csQq=ZjxCD5@8kc=toEHRBRSiutLe>>y-o2TPR(z
zCsf|GmTR+G70fBxujp(APdjIoTLm{^%vWxZDSf=F>&O<+IiX-R1I-3sMIGo};%iph
zh5K1=OT2)^Mp_nwY}g$oN(<RrUeb0t7#b=U-b4>R`s|dNP!ws&vtnqxd%NxZy~PhN
z$;Uq>DlSSL56Vfw<E)7FfryvZV>Rgy%A5<i9X}|NelB8N#^XdP5ibpaywY-#>Z~kc
zCG_@!zGujyyMJ*S?db$$<7_m}#Yhxd@VFccnOMzhKTli#dW)xc0mkWPLlZpQ{ieO&
zzO(rFl^gQOIM32Vi}O^KarfI_-aT%9m*g3TMIP_B?|+LYIBgg=&y+R}42;XO6cCse
zlHs<I6ba9>0s_)Y^HK@pDcC^6N6Tz%{A3KW-1vi1juLG`UH1A%8pNGk6sM7Nz)B~`
zinNy%y3@Gek4}B*$6lI?r09eY@jXj`4ve?ll;$QHWK!uK>~~7!`xp#2_CD`EP(rHi
zZGDgw-CJck!8=ynJDL7!((jIs2C(BnSIM-CY|!ZT7?KOvVc!KS>JtE$y0lJx%4id?
zPDA@P0c(`~60(r4!CSMf2D0)RD7`u*|Af{5b4uFeT>mFIo6F>s9voX@U6NQ(Wr%=<
zS3=DtvX0O|SVg#mu!gXX&_s9*;P}e(;9Q0UhNn8-__|Cu1Z+Pm5_uG(`ylzCD=(w!
zI|vvROZWhL=%g5$`V`<lxR}*wjk(k~r5qYRx1o|^8a#V2Zt$?S{=N$xO`z7Yia;HV
zrVi9bTG0yr8@4`r6@v;!+bw1yjKW09<jDBqP(#MFT-gEx@;X2VvP_?)4J}_djcIC`
z6e@?T?LAAb9Z*tu%|1lx8ph=|3|^v&5|%1n2>vE4(S{`o#kg{2P~bV6vopf3CG51H
z`>4g_Tc9i72Drf3=Blk5^zcQ(YZnMZ-rfdnOV<Uu8%P&(uic7_|0GkBB)7FjUV%v{
wLt4r=pl7`(Kg1p$&Z?Z-$+{f9ZNi(Ql23B6gLP72+||kJ&eoe-SFZ+t1IS488~^|S

diff --git a/src/__pycache__/finch.cpython-310.pyc b/src/__pycache__/finch.cpython-310.pyc
deleted file mode 100644
index 41294d74569f3666ddc49b6da790ec03f7494615..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1879
zcmZ`(&u<$=6rP#g9j`aBlbWcdfWRs(l0k$vAR$FjR7hz#AYZCV$TC{3cgD^p_O3fK
zritaAQi&foE{J1t%zwjquAFk=QgPwLd*f^yr(vx5{LPy;^S*iWW{X-aBGCT)C+z)E
zA>=O{Tx=c;?nBoNfJa0SL0>>WVjUvbW76_curD+Yqx;bHcL0)fs309CsPqIAUf&nK
z2wwOdU(^K`6<~n~B^OobIL}2SmcUvOOon|XmPHLlRpCLb6&pOv@^shop*$!?(sCuu
zMCI+2L8!7J51^xR{X2jGy~h-HKVe7o7c!$W60@I3pE@m}@dQ7j56BVP{Q-d=0~QDz
z^8o>@I1HVo>M(M+<Z#*TRe^IY?p6Dl9M?~9{fhHj6(R6zzd{z_G}ZPQh$Ck{fc1LW
zAf-4yZ+Hrvc?<f>H2_rb1Ak6oPjW(jV^1Obr{t7cKP|?Gr_8eTyOw6Bw8OK{H{!3q
zQX#DR_lup)?h`GQ?tWu-lf3(&NGBti8{K`BnQte(?)b2eIqhndb{$(EAKGYZm}!$1
zqwzLg=Sx(xMy9u1`q$$)%QF+l>s!MjO@?|KNa=otY5(7oC@3-FgsCdBC4~Ab+X}K(
z07tF?dDv>$YVXj<M5*M^hNg&dq!lW%flBg$w4ss%h%c4p+9c_|?(ifv*^kmPeGmFZ
z2MQ$-@otAdQy?7v`@`Z{426{C8pbxr^6|tdd<vEq69a>em%!G`dOsV-xjZm&F>W#I
zYdP$@;PX>B?Wop<WmZs`ZUU?_PT!^x<qJP&@xbOy>x=1J$QsrHrg8_mz6&rTdr-$W
zh=HoygF4=4YDHk3x@ww1vEcldgq>SjUi%C;QCLMSPrU<w)*H&)sc%vBK2Bnd%)uSP
zgHm`GOd4-}4YW7dv^rM_GnghJ5A2eX<6)9YtfLe~mJRtU(U_VU2;74Qw>2+$+J?B8
zAJF5%e+XRNMz}0wG%>fpuF<<rOA%mQ$P&(CN$sHP-v9&hoX+SmWa5NU2n>vs%uvIQ
zJrLvz?<NsGehtbw5tQtL7k|U6a)np;hF7)p5>d(AtpynOLd@5GOPBm0@|Awe=qGB&
zd<M$l8&Ypi`KQ>Tsh@nm*>sn!@bacXvxkP}oTtFgFk6;J)9Pb<CCz)A&5~{a4ctbS
zv?`V-<FU+z^|VnIYQos4uZq$6)4LAas2jMKzgJ{=i@CeByf^9hrMi5Rl{ki7;`k$2
zpz%t5D65FRccDiVORdC+PHW}Ea4R7I7FD|y;UmkFk&I&-#qp>RlOgiuIDR@whVvPP
zUrhA@0!CAxAlyOt7~wO7*Tv?T``X}J!LIQm5RwLsZeFi6e1$eFTlbc(SZKqoxsYwQ
J8gtwr{{iK5h>QRL

diff --git a/src/__pycache__/lexome.cpython-310.pyc b/src/__pycache__/lexome.cpython-310.pyc
deleted file mode 100644
index dac1535352f156b951902f62d882d9eea58762c0..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 6464
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
UZn02wbN_+jPW3m@3;zl8zh}pPs{jB1

diff --git a/src/__pycache__/preprocessor.cpython-310.pyc b/src/__pycache__/preprocessor.cpython-310.pyc
deleted file mode 100644
index a0d4e1bc73ce1ee6f834e97d2c723328a1d8cea6..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 3502
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

diff --git a/src/__pycache__/visual.cpython-310.pyc b/src/__pycache__/visual.cpython-310.pyc
deleted file mode 100644
index 010e20134144623aa165c809882ad95ea2dec1fa..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1097
zcmZ8gOK;Oa5Z<-duRK}~sG*dD#RVckRG>woLa1rtrcooON~sWzD=W>qYD)9ydV`2n
zPAzx-1_%DoUODw2AWqEMjv5$i9=r3+%&up4TrB1g(D&cw$xjubUvjZXIxMz<qo*Jm
zh$4z_fUgw~Q6<Dw1twHG)u~R68{#QcJ49u(59ogg!)hBiS_cs#4^sqK?5R}o2vt3e
z5>Ka^XHeZUso`1F^m5el@-zqe@<Q#8FJf)2`(|^PsEt&;PSwj)y-L-KVNBM#>xoS5
zjiFmE2r~#qy<r#xA{PY1F`ZsWyATAI)80kq(f6Ec-RTIuy}#2say-zrk5yL~?fpi_
zalrUc?YK?1A;@mE*%HKY>oq}k+O4{09k~$NYP!x3#0qfFMEu#TZTUx0$Rgk2XT6bM
zANQxjaKt0OG2naC6Mr&09gO;Ce#H9z=RpLAsZ3@}{xQkXeGn!h_}|aO2|^G)n}i_4
zFI?y><Wn|s`wE223A&0j;2LnW0vS2_s$3xgUHqgl*x;C>bA>7;@SLk9bcIXk8e{17
zp+u>GdNM~zUy52l5I}5Y2$+RA;=epPpbj#WMvb)2T`sO)!*#QoCSZFR*2ro?#Jnc8
zz|WI&n>3eZqWO8<Im$|Jws0a^kXTxzOW%}LR6=z5E@%0kD@fDbZO2Aes$-kUzs5`u
zaju(n{n!@TLDg;6VzZlQfaL)p$l*cfeXKv1WXHOl81afbwkOaOKC@59Y}n&cZP~XF
zfo^4EVzpAKl&!Rt+Jp^8oEfms<f}|-GYc$1E~f*YRATZ)mQ}VS0n5^dPws||73Gee
z)|4X{JqAIrf^+y0@Ph>{S30)A_YAXDfI(I{a6*kZOEwnrCgYqWH{YgD=Up<K1Ok@O
G!~9>Vzuk5K

-- 
2.34.1.windows.1

From 940c64c892649e744d095b7c3b018ac810de30d2 Mon Sep 17 00:00:00 2001
From: Arthur Lee <arthur@example.com>
Date: Mon, 14 Feb 2022 04:53:52 +0800
Subject: [PATCH] * Converted project to a module. Changed import statements
 for module to work.  To build a distributable  module: `poetry build` * Added
 new entry point (pyfinch) to pyproject.toml, To run: `poetry run pyfinch`. *
 More temporary folders added to .gitignore

---
 .gitignore                       |  2 ++
 {src => pyfinch}/aviary.py       |  5 +++--
 {src => pyfinch}/bytedict.py     |  2 +-
 {src => pyfinch}/finch.py        |  0
 {src => pyfinch}/lexome.py       |  4 ++--
 {src => pyfinch}/preprocessor.py |  2 +-
 {src => pyfinch}/terminal.py     | 16 ++++++++--------
 {src => pyfinch}/visual.py       |  0
 pyproject.toml                   |  3 +++
 src/__init__.py                  |  0
 10 files changed, 20 insertions(+), 14 deletions(-)
 rename {src => pyfinch}/aviary.py (95%)
 rename {src => pyfinch}/bytedict.py (99%)
 rename {src => pyfinch}/finch.py (100%)
 rename {src => pyfinch}/lexome.py (99%)
 rename {src => pyfinch}/preprocessor.py (99%)
 rename {src => pyfinch}/terminal.py (94%)
 rename {src => pyfinch}/visual.py (100%)
 delete mode 100644 src/__init__.py

diff --git a/.gitignore b/.gitignore
index 61f2dc9..6c11c82 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,3 @@
 **/__pycache__/
+dist/
+build/
diff --git a/src/aviary.py b/pyfinch/aviary.py
similarity index 95%
rename from src/aviary.py
rename to pyfinch/aviary.py
index 5af0331..bfbe22f 100644
--- a/src/aviary.py
+++ b/pyfinch/aviary.py
@@ -1,5 +1,6 @@
-from finch import Finch
-from lexome import *
+from .finch import Finch
+
+from .lexome import *
 
 
 def run_aviary(
diff --git a/src/bytedict.py b/pyfinch/bytedict.py
similarity index 99%
rename from src/bytedict.py
rename to pyfinch/bytedict.py
index 3d11183..f8e0b37 100644
--- a/src/bytedict.py
+++ b/pyfinch/bytedict.py
@@ -1,4 +1,4 @@
-from visual import pretty
+from .visual import pretty
 
 
 # Generates byte dictionary per running instance.
diff --git a/src/finch.py b/pyfinch/finch.py
similarity index 100%
rename from src/finch.py
rename to pyfinch/finch.py
diff --git a/src/lexome.py b/pyfinch/lexome.py
similarity index 99%
rename from src/lexome.py
rename to pyfinch/lexome.py
index 337bc22..1bd7c74 100644
--- a/src/lexome.py
+++ b/pyfinch/lexome.py
@@ -1,7 +1,7 @@
 import copy
 
-from finch import Finch
-from visual import pretty
+from .finch import Finch
+from .visual import pretty
 
 
 def run_op(str_dict: dict, finch: Finch) -> str:
diff --git a/src/preprocessor.py b/pyfinch/preprocessor.py
similarity index 99%
rename from src/preprocessor.py
rename to pyfinch/preprocessor.py
index a42924e..81710b7 100644
--- a/src/preprocessor.py
+++ b/pyfinch/preprocessor.py
@@ -1,4 +1,4 @@
-from visual import pretty
+from .visual import pretty
 
 
 def pre_process() -> tuple[list[list[str]], list[str]]:
diff --git a/src/terminal.py b/pyfinch/terminal.py
similarity index 94%
rename from src/terminal.py
rename to pyfinch/terminal.py
index d787dac..578d5d3 100644
--- a/src/terminal.py
+++ b/pyfinch/terminal.py
@@ -1,5 +1,12 @@
+from . import aviary
+from . import bytedict
+from . import preprocessor
+from .visual import pretty
+
+
 def main() -> None:
-    os.chdir("..")
+    # import os
+    # os.chdir("..")
     runInterface()
 
 
@@ -81,11 +88,4 @@ def about() -> None:
 
 
 if __name__ == "__main__":
-    import os
-
-    import aviary
-    import bytedict
-    import preprocessor
-    from visual import pretty
-
     main()
diff --git a/src/visual.py b/pyfinch/visual.py
similarity index 100%
rename from src/visual.py
rename to pyfinch/visual.py
diff --git a/pyproject.toml b/pyproject.toml
index 4c54b45..e49b30a 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -11,6 +11,9 @@ python = "^3.10"
 black = "^22.1.0"
 isort = "^5.10.1"
 
+[tool.poetry.scripts]
+pyfinch = "pyfinch.terminal:main"
+
 [build-system]
 requires = ["poetry-core>=1.0.0"]
 build-backend = "poetry.core.masonry.api"
diff --git a/src/__init__.py b/src/__init__.py
deleted file mode 100644
index e69de29..0000000
-- 
2.34.1.windows.1

From e7393d31d194cc693b16d4b2747ee4013d8c79b7 Mon Sep 17 00:00:00 2001
From: Arthur Lee <arthur@example.com>
Date: Mon, 14 Feb 2022 10:55:51 +0800
Subject: [PATCH] Replaced 'match' with 'if-elif-else' because mypy does not
 support `match` yet

---
 .gitignore              |  1 +
 pyfinch/__init__.py     |  0
 pyfinch/aviary.py       |  1 -
 pyfinch/lexome.py       | 68 +++++++++++++++++++++++------------------
 pyfinch/preprocessor.py | 40 ++++++++++++------------
 pyfinch/terminal.py     |  4 +--
 pyfinch/visual.py       | 41 +++++++++++--------------
 7 files changed, 79 insertions(+), 76 deletions(-)
 create mode 100644 pyfinch/__init__.py

diff --git a/.gitignore b/.gitignore
index 6c11c82..bc007a1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
 **/__pycache__/
+**/.mypy_cache/
 dist/
 build/
diff --git a/pyfinch/__init__.py b/pyfinch/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/pyfinch/aviary.py b/pyfinch/aviary.py
index bfbe22f..a322ae2 100644
--- a/pyfinch/aviary.py
+++ b/pyfinch/aviary.py
@@ -1,5 +1,4 @@
 from .finch import Finch
-
 from .lexome import *
 
 
diff --git a/pyfinch/lexome.py b/pyfinch/lexome.py
index 1bd7c74..51c681d 100644
--- a/pyfinch/lexome.py
+++ b/pyfinch/lexome.py
@@ -32,15 +32,14 @@ def next_nop(finch: Finch, str_dict: dict) -> int:
     next_str: str = str_dict[
         finch.lexome[tinc(finch.inst_h, len(finch.lexome))].to_bytes(1, "big")
     ]
-    match next_str:
-        case "nop_A":
-            return 0
-        case "nop_B":
-            return 1
-        case "nop_C":
-            return 2
-        case _:
-            return 3
+    if next_str == "nop_A":
+        return 0
+    elif next_str == "nop_B":
+        return 1
+    elif next_str == "nop_C":
+        return 2
+    else:
+        return 3
 
 
 # Instruction No-Ops
@@ -220,13 +219,16 @@ def mov_head(finch: Finch, str_dict: dict) -> None:
     head: int = next_nop(finch, str_dict)
     if head == 3:
         head = 0
-    match head:
-        case 0:
-            finch.inst_h = copy.copy(finch.flow_h)
-        case 1:
-            finch.read_h = copy.copy(finch.flow_h)
-        case 2:
-            finch.writ_h = copy.copy(finch.flow_h)
+
+    if head == 0:
+        finch.inst_h = copy.copy(finch.flow_h)
+    elif head == 1:
+        finch.read_h = copy.copy(finch.flow_h)
+    elif head == 2:
+        finch.writ_h = copy.copy(finch.flow_h)
+
+    # XXX: What if head > 2?
+
     finch.inc()
 
 
@@ -235,13 +237,16 @@ def jmp_head(finch: Finch, str_dict: dict) -> None:
     head: int = next_nop(finch, str_dict)
     if head == 3:
         head = 0
-    match head:
-        case 0:
-            finch.inst_h = tinc(finch.inst_h, len(finch.lexome), finch.register[2])
-        case 1:
-            finch.read_h = tinc(finch.read_h, len(finch.lexome), finch.register[2])
-        case 2:
-            finch.writ_h = tinc(finch.read_h, len(finch.lexome), finch.register[2])
+
+    if head == 0:
+        finch.inst_h = tinc(finch.inst_h, len(finch.lexome), finch.register[2])
+    elif head == 1:
+        finch.read_h = tinc(finch.read_h, len(finch.lexome), finch.register[2])
+    elif head == 2:
+        finch.writ_h = tinc(finch.read_h, len(finch.lexome), finch.register[2])
+
+    # XXX: What if head > 2?
+
     finch.inc()
 
 
@@ -250,13 +255,16 @@ def get_head(finch: Finch, str_dict: dict) -> None:
     head: int = next_nop(finch, str_dict)
     if head == 3:
         head = 0
-    match head:
-        case 0:
-            finch.register[2] = bytearray(finch.inst_h.to_bytes(4, "big"))
-        case 1:
-            finch.register[2] = bytearray(finch.read_h.to_bytes(4, "big"))
-        case 2:
-            finch.register[2] = bytearray(finch.writ_h.to_bytes(4, "big"))
+
+    if head == 0:
+        finch.register[2] = bytearray(finch.inst_h.to_bytes(4, "big"))
+    elif head == 1:
+        finch.register[2] = bytearray(finch.read_h.to_bytes(4, "big"))
+    elif head == 2:
+        finch.register[2] = bytearray(finch.writ_h.to_bytes(4, "big"))
+
+    # XXX: What if head > 2?
+
     finch.inc()
 
 
diff --git a/pyfinch/preprocessor.py b/pyfinch/preprocessor.py
index 81710b7..d2912ab 100644
--- a/pyfinch/preprocessor.py
+++ b/pyfinch/preprocessor.py
@@ -117,25 +117,27 @@ def finch_parser(name: str) -> tuple[list[str], str, int]:
                 "PANIC",
                 "Finch Config was formatted incorrectly. Blank fields were found.",
             )
-        match (entry[0]):
-            case "\n":
-                pass
-            case "#":
-                pass
-            case "LEXOME":
-                lexome_name = entry[1].strip()
-            case "SIZE":
-                size = int(entry[1].strip())
-            case "ORG":
-                org_names = list(map(str.strip, entry[1::2]))
-                org_pops = list(map(int, list(map(str.strip, entry[2::2]))))
-            case _:
-                pretty(
-                    "PANIC",
-                    "Finch Config contains unknown command in line {} and command {}".format(
-                        row, entry[0]
-                    ),
-                )
+
+        en0 = entry[0]
+        if en0 == "\n":
+            pass
+        elif en0 == "#":
+            pass
+        elif en0 == "LEXOME":
+            lexome_name = entry[1].strip()
+        elif en0 == "SIZE":
+            size = int(entry[1].strip())
+        elif en0 == "ORG":
+            org_names = list(map(str.strip, entry[1::2]))
+            org_pops = list(map(int, list(map(str.strip, entry[2::2]))))
+        else:
+            pretty(
+                "PANIC",
+                "Finch Config contains unknown command in line {} and command {}".format(
+                    row, entry[0]
+                ),
+            )
+
     if size == -1:
         pretty("PANIC", "Finch Config did not specify a valid aviary size.")
     return (org_names, org_pops, lexome_name, size)
diff --git a/pyfinch/terminal.py b/pyfinch/terminal.py
index 578d5d3..e2d08eb 100644
--- a/pyfinch/terminal.py
+++ b/pyfinch/terminal.py
@@ -1,6 +1,4 @@
-from . import aviary
-from . import bytedict
-from . import preprocessor
+from . import aviary, bytedict, preprocessor
 from .visual import pretty
 
 
diff --git a/pyfinch/visual.py b/pyfinch/visual.py
index fa03f30..79ccee7 100644
--- a/pyfinch/visual.py
+++ b/pyfinch/visual.py
@@ -12,26 +12,21 @@ class col:
 
 def pretty(type: str, text: str) -> None:
     b = col
-    match type:
-        case "INFO":
-            print(col.OKGREEN + "[INFO] " + col.ENDC + text)
-        case "HEADER":
-            print(col.OKGREEN + text + col.ENDC)
-        case "WARNING":
-            print(col.WARNING + "[WARNING] " + col.ENDC + text)
-        case "PANIC":
-            print(col.FAIL + "[PANIC] " + text + col.ENDC)
-            quit()
-        case "BOLD":
-            print(col.BOLD + text + col.BOLD)
-        case "SPRT":
-            print(col.OKBLUE + "----- " + text + " -----" + col.ENDC)
-        case _:
-            print(
-                col.WARNING
-                + "[WARNING] "
-                + col.ENDC
-                + "No pretty format for: "
-                + text[0:3]
-                + "..."
-            )
+
+    if type == "INFO":
+        print(f'{col.OKGREEN}[INFO]{col.ENDC} {text}')
+    elif type == "HEADER":
+        print(f'{col.OKGREEN}{text}{col.ENDC}')
+    elif type == "WARNING":
+        print(f'{col.WARNING}[WARNING]{col.ENDC} {text}')
+    elif type == "PANIC":
+        print(f'{col.FAIL}[PANIC] {text}{col.ENDC}')
+        quit()
+    elif type == "BOLD":
+        print(f'{col.BOLD}{text}{col.BOLD}')
+    elif type == "SPRT":
+        print(f'{col.OKBLUE}----- {text} -----{col.ENDC}')
+    else:
+        print(
+            f'{col.WARNING}[WARNING]{col.ENDC} No pretty format for: {text[:3]} ..."'
+        )
-- 
2.34.1.windows.1

From 919a1faa8931eb8d03d4218076c4a4bd3c1f1558 Mon Sep 17 00:00:00 2001
From: Arthur Lee <arthur@example.com>
Date: Mon, 14 Feb 2022 11:56:37 +0800
Subject: [PATCH] * Make `mypy` happy * Restructured terminal.py/runInterface()
 and terminal.py/optionHandler()   Moved out OPTIONS and build at compile
 time. More efficient and easier to read.   optionnHandler() now handle
 options only.

---
 pyfinch/bytedict.py     | 42 ++---------------------------------------
 pyfinch/preprocessor.py | 12 ++++++------
 pyfinch/terminal.py     | 42 ++++++++++++++++++++++++-----------------
 pyfinch/visual.py       | 16 +++++++---------
 4 files changed, 40 insertions(+), 72 deletions(-)

diff --git a/pyfinch/bytedict.py b/pyfinch/bytedict.py
index f8e0b37..aafd47e 100644
--- a/pyfinch/bytedict.py
+++ b/pyfinch/bytedict.py
@@ -1,6 +1,8 @@
 from .visual import pretty
 
 
+# Converts lexome set to binary dictionary.
+# Also does some checking to ensure that instruction set is a subset of all master operations.
 # Generates byte dictionary per running instance.
 def to_dict(lexomes: list[str]) -> dict:
     inc_int: int = 0
@@ -37,46 +39,6 @@ def to_dict(lexomes: list[str]) -> dict:
     return ret_dict
 
 
-# Converts lexome set to binary dictionary.
-# Also does some checking to ensure that instruction set is a subset of all master operations.
-def to_dict(lexomes: list[str]) -> list[bytearray]:
-    inc_int: int = 0
-    master_lexome: list[str] = []
-    lexome_clean: list[str] = list(set(lexomes))
-    ret_dict: dict = dict()
-    try:
-        f = open("config\master_lexome.cfg", "r", encoding="utf-8")
-    except:
-        pretty(
-            "PANIC",
-            "master_lexome.cfg was not found in the config subfolder. Unable to parse master instruction set.",
-        )
-    lines: list[str] = f.readlines()
-    f.close()
-    for l in lines:
-        first_str: str = l.split("#")[0].strip()
-        if first_str != "":
-            master_lexome.append(first_str)
-
-    for l in lexome_clean:
-        if l not in master_lexome:
-            pretty(
-                "PANIC",
-                "Instruction set contains implemented operation ({}). Unable to parse master instruction set.".format(
-                    l
-                ),
-            )
-        ret_dict[l] = inc_int.to_bytes(1, "big")
-        inc_int += 1
-    if len(lexomes) != len(lexome_clean):
-
-        pretty("WARNING", "Instruction set contains duplicate instructions")
-    pretty("INFO", "Validated lexome sets")
-
-    pretty("INFO", "Loaded binary dictionary")
-    return ret_dict
-
-
 # Using a provided dictionary, translates a lexome to bytearrays.
 def translate_to_bytes(org: list[str], l_dict: dict) -> bytearray:
     ret_bytes: bytearray = bytearray()
diff --git a/pyfinch/preprocessor.py b/pyfinch/preprocessor.py
index d2912ab..141c894 100644
--- a/pyfinch/preprocessor.py
+++ b/pyfinch/preprocessor.py
@@ -1,12 +1,12 @@
 from .visual import pretty
 
 
-def pre_process() -> tuple[list[list[str]], list[str]]:
+def pre_process() -> tuple[list[list[str]], list[int], list[str], int]:
     org_names: list[str] = []
     org_pops: list[int] = []
     lexome_name: str = ""
-    orgs, lexome = list[list[str]], list[str]
-    orgs, lexome = [], []
+    orgs: list[list[str]] = []
+    lexome: list[str] = []
     size: int = 0
 
     # Parses Config File Once and all at once.
@@ -34,7 +34,7 @@ def pre_process() -> tuple[list[list[str]], list[str]]:
                     org_name
                 ),
             )
-        lines: list[str] = f.readlines()
+        lines = f.readlines()
         f.close()
         temp_org: list[str] = org_parser(lines)
         if len(temp_org) == 0:
@@ -55,7 +55,7 @@ def pre_process() -> tuple[list[list[str]], list[str]]:
 
 
 # Validates that organism org complies to the instruction set lexome_set
-def org_check(lexome_set: list[str], org: list[str]) -> tuple[bool, str]:
+def org_check(lexome_set: list[str], org: list[str]) -> tuple[bool, str | None]:
     for x in org:
         if x not in lexome_set:
             return (False, x)
@@ -100,7 +100,7 @@ def lexome_parser(ops: list[str]) -> list[str]:
 
 
 # Parses and checks config file. File has to be in a subfolder config\default.cfg.
-def finch_parser(name: str) -> tuple[list[str], str, int]:
+def finch_parser(name: str) -> tuple[list[str], list[int], str, int]:
     try:
         with open("config\{}.cfg".format(name), "r", encoding="utf-8") as f:
             lines: list[str] = f.readlines()
diff --git a/pyfinch/terminal.py b/pyfinch/terminal.py
index e2d08eb..40be03a 100644
--- a/pyfinch/terminal.py
+++ b/pyfinch/terminal.py
@@ -1,6 +1,12 @@
 from . import aviary, bytedict, preprocessor
 from .visual import pretty
 
+OPTIONS = [
+    (0, "Run Simulation - Run a preset simulation", "run_sim()"),
+    (1, "About - Information about PYFINCH", "about()"),
+    (2, "Quit - Quit PYFINCH", "quit()"),
+]
+
 
 def main() -> None:
     # import os
@@ -44,33 +50,35 @@ def runInterface() -> None:
     title_buffer: str = "-" * 23 + "\n"
     title_buffer += "PYFINCH - ALPHA BUILD\n"
     title_buffer += "-" * 23
-    for i, (option, _) in enumerate(optionHandler(get=True)):
-        buffer += "[" + str(i) + "]: " + option + "\n"
+
+    # Alternatively, using `list comprehension`
+    #   buffer = '\n'.join(
+    #                   f"[{i}] {option}" for (i, option, _) in OPTIONS
+    #                   )
+    for i, option, _ in OPTIONS:
+        buffer += f"[{i}] {option}\n"
+
     while True:
         pretty("HEADER", title_buffer)
         pretty("BOLD", buffer)
-        action: list[(str, str)] = optionHandler(input())
-        if action[0][0] == "NOP":
+        i, option, code = optionHandler(input())
+        if i == -1:
             print("Invalid Action")
         else:
-            exec(action[1])
+            exec(code)
 
 
 # Handles the display menus - easily updateable.
-def optionHandler(option: str = None, get: bool = False) -> list[(str, str)]:
-    options: list[(str, str)] = []
-    options.append(("Run Simulation - Run a preset simulation", "run_sim()"))
-    options.append(("About - Information about PYFINCH", "about()"))
-    options.append(("Quit - Quit PYFINCH", "quit()"))
-    if get:
-        return options
+def optionHandler(option: str = None) -> tuple[int, str, str]:
     try:
-        choice: int = int(option)
+        choice: int = int(option)  # type: ignore
     except:
-        return [("NOP", "NOP")]
-    if choice >= len(options) or choice < 0:
-        return [("NOP", "NOP")]
-    return options[choice]
+        return -1, "NOP", "pass"
+
+    if choice >= len(OPTIONS) or choice < 0:
+        return -1, "NOP", "pass"
+
+    return OPTIONS[choice]
 
 
 # Option to display About.
diff --git a/pyfinch/visual.py b/pyfinch/visual.py
index 79ccee7..d629a0d 100644
--- a/pyfinch/visual.py
+++ b/pyfinch/visual.py
@@ -14,19 +14,17 @@ def pretty(type: str, text: str) -> None:
     b = col
 
     if type == "INFO":
-        print(f'{col.OKGREEN}[INFO]{col.ENDC} {text}')
+        print(f"{col.OKGREEN}[INFO]{col.ENDC} {text}")
     elif type == "HEADER":
-        print(f'{col.OKGREEN}{text}{col.ENDC}')
+        print(f"{col.OKGREEN}{text}{col.ENDC}")
     elif type == "WARNING":
-        print(f'{col.WARNING}[WARNING]{col.ENDC} {text}')
+        print(f"{col.WARNING}[WARNING]{col.ENDC} {text}")
     elif type == "PANIC":
-        print(f'{col.FAIL}[PANIC] {text}{col.ENDC}')
+        print(f"{col.FAIL}[PANIC] {text}{col.ENDC}")
         quit()
     elif type == "BOLD":
-        print(f'{col.BOLD}{text}{col.BOLD}')
+        print(f"{col.BOLD}{text}{col.BOLD}")
     elif type == "SPRT":
-        print(f'{col.OKBLUE}----- {text} -----{col.ENDC}')
+        print(f"{col.OKBLUE}----- {text} -----{col.ENDC}")
     else:
-        print(
-            f'{col.WARNING}[WARNING]{col.ENDC} No pretty format for: {text[:3]} ..."'
-        )
+        print(f'{col.WARNING}[WARNING]{col.ENDC} No pretty format for: {text[:3]} ..."')
-- 
2.34.1.windows.1

From 9a6650734273aa1057ea0d68f12fc7132c59dccb Mon Sep 17 00:00:00 2001
From: Arthur Lee <arthur@example.com>
Date: Mon, 14 Feb 2022 13:14:39 +0800
Subject: [PATCH] * `const.py:StrDict`, new type for more precise type checks *
 where type is `dict`, replace with `dict[..., ...]` for more precise type
 checks,    mypy will make use of the type provided for inference * Removed
 unnecessary type annotations, mypy is smart enough to infer its type    base
 on the value assigned (definition)

---
 pyfinch/aviary.py       |  9 ++--
 pyfinch/bytedict.py     | 36 +++++++++-------
 pyfinch/const.py        |  3 ++
 pyfinch/finch.py        | 24 +++++------
 pyfinch/lexome.py       | 96 +++++++++++++++++++++--------------------
 pyfinch/preprocessor.py | 27 +++++-------
 pyfinch/terminal.py     | 19 ++++----
 pyfinch/visual.py       |  2 +-
 8 files changed, 110 insertions(+), 106 deletions(-)
 create mode 100644 pyfinch/const.py

diff --git a/pyfinch/aviary.py b/pyfinch/aviary.py
index a322ae2..4541080 100644
--- a/pyfinch/aviary.py
+++ b/pyfinch/aviary.py
@@ -1,5 +1,7 @@
+from .const import StrDict
 from .finch import Finch
-from .lexome import *
+from .lexome import run_op
+from .visual import pretty
 
 
 def run_aviary(
@@ -7,16 +9,17 @@ def run_aviary(
     org_pops: list[int],
     binary_inst: bytearray,
     binary_dict: dict,
-    str_dict: dict,
+    str_dict: StrDict,
     size: int,
 ) -> None:
     # binary_dict   Key:lexemes Val:binary
     # str_dict      Key:binary  Val:lexemes
-    finches: list[Finch] = []
+    finches = []
     # Load finches
     for index, l in enumerate(binary_lexome):
         for i in range(org_pops[index]):
             finches.append(Finch(l))
+
     pretty("INFO", "Innoculated with starting Pop")
     pretty("INFO", "Running Simulation...")
     for i in range(10):
diff --git a/pyfinch/bytedict.py b/pyfinch/bytedict.py
index aafd47e..4a46d3b 100644
--- a/pyfinch/bytedict.py
+++ b/pyfinch/bytedict.py
@@ -1,25 +1,28 @@
+from .const import StrDict
 from .visual import pretty
 
 
 # Converts lexome set to binary dictionary.
-# Also does some checking to ensure that instruction set is a subset of all master operations.
+# Also does some checking to ensure that instruction set is a subset of all
+#   master operations.
 # Generates byte dictionary per running instance.
-def to_dict(lexomes: list[str]) -> dict:
-    inc_int: int = 0
-    master_lexome: list[str] = []
-    lexome_clean: list[str] = list(set(lexomes))
-    ret_dict: dict = dict()
+def to_dict(lexomes: list[str]) -> dict[str, bytes]:
+    inc_int = 0
+    master_lexome = []
+    lexome_clean = list(set(lexomes))
+    ret_dict = dict()
     try:
         f = open("config\master_lexome.cfg", "r", encoding="utf-8")
     except:
         pretty(
             "PANIC",
-            "master_lexome.cfg was not found in the config subfolder. Unable to parse master instruction set.",
+            "master_lexome.cfg was not found in the config subfolder."
+            " Unable to parse master instruction set.",
         )
-    lines: list[str] = f.readlines()
+    lines = f.readlines()
     f.close()
     for l in lines:
-        first_str: str = l.split("#")[0].strip()
+        first_str = l.split("#")[0].strip()
         if first_str != "":
             master_lexome.append(first_str)
 
@@ -27,29 +30,30 @@ def to_dict(lexomes: list[str]) -> dict:
         if l not in master_lexome:
             pretty(
                 "PANIC",
-                "Instruction set contains implemented operation ({}). Unable to parse master instruction set.".format(
-                    l
-                ),
+                f"Instruction set contains implemented operation ({l})."
+                " Unable to parse master instruction set.",
             )
         ret_dict[l] = inc_int.to_bytes(1, "big")
         inc_int += 1
+
     if len(lexomes) != len(lexome_clean):
         pretty("WARNING", "Instruction set contains duplicate instructions")
+
     pretty("INFO", "Validated INST set")
     return ret_dict
 
 
 # Using a provided dictionary, translates a lexome to bytearrays.
-def translate_to_bytes(org: list[str], l_dict: dict) -> bytearray:
-    ret_bytes: bytearray = bytearray()
+def translate_to_bytes(org: list[str], l_dict: dict[str, bytes]) -> bytearray:
+    ret_bytes = bytearray()
     for o in org:
         ret_bytes.extend(l_dict[o])
     return ret_bytes
 
 
 # Using a provided dictionary, translates a bytearray to lexome.
-def translate_to_str(org: bytearray, l_dict: dict) -> list[str]:
-    ret_list: list[str] = []
+def translate_to_str(org: bytes, l_dict: dict[bytes, str]) -> list[str]:
+    ret_list = []
     for x in org:
         ret_list.append(l_dict[x.to_bytes(1, "big")])
     return ret_list
diff --git a/pyfinch/const.py b/pyfinch/const.py
new file mode 100644
index 0000000..abd1ffd
--- /dev/null
+++ b/pyfinch/const.py
@@ -0,0 +1,3 @@
+import typing as T
+
+StrDict = T.NewType("StrDict", dict[bytes, str])
diff --git a/pyfinch/finch.py b/pyfinch/finch.py
index edf062c..965f4e2 100644
--- a/pyfinch/finch.py
+++ b/pyfinch/finch.py
@@ -1,23 +1,23 @@
 class Finch:
     def __init__(self, lexome: bytearray) -> None:
         # Components - CPU, Memory, Output
-        i32_BA: bytearray = bytearray((0).to_bytes(4, "big"))
+        i32_BA = bytearray((0).to_bytes(4, "big"))
         self.lexome = lexome
-        self.register: list[bytearray] = [i32_BA.copy() for i in range(3)]
+        self.register = [i32_BA.copy() for i in range(3)]
         self.stacks: list[list[bytearray]] = [[], []]
-        self.active: int = 0
+        self.active = 0
         self.s1: list[bytearray] = []
         self.s2: list[bytearray] = []
-        self.read_h: int = 0
-        self.writ_h: int = 0
-        self.flow_h: int = 0
-        self.inst_h: int = 0
-        self.input: list[bytearray] = [i32_BA.copy() for i in range(3)]
-        self.output: bytearray = i32_BA.copy()
+        self.read_h = 0
+        self.writ_h = 0
+        self.flow_h = 0
+        self.inst_h = 0
+        self.input = [i32_BA.copy() for i in range(3)]
+        self.output = i32_BA.copy()
 
         # Attributes
-        self.age: int = 0
-        self.skip_next_op: bool = False
+        self.age = 0
+        self.skip_next_op = False
 
         # C
         del i32_BA
@@ -36,7 +36,7 @@ class Finch:
 
     # Print function.
     def __str__(self) -> str:
-        buffer: list[str] = []
+        buffer = []
         buffer.append("-----\n")
         buffer.append("aX: ")
         buffer.append(str(int.from_bytes(self.register[0], "big")))
diff --git a/pyfinch/lexome.py b/pyfinch/lexome.py
index 51c681d..e8310ae 100644
--- a/pyfinch/lexome.py
+++ b/pyfinch/lexome.py
@@ -1,12 +1,14 @@
 import copy
+import typing as T
 
+from .const import StrDict
 from .finch import Finch
 from .visual import pretty
 
 
-def run_op(str_dict: dict, finch: Finch) -> str:
-    op: str = str_dict[finch.lexome[finch.inst_h].to_bytes(1, "big")]
-    exec(op + "(finch,str_dict)")
+def run_op(str_dict: StrDict, finch: Finch) -> str:
+    op = str_dict[finch.lexome[finch.inst_h].to_bytes(1, "big")]
+    exec(f"{op}(finch,str_dict)")
     return op
 
 
@@ -28,8 +30,8 @@ def comp(register: int) -> int:
     return register + 1
 
 
-def next_nop(finch: Finch, str_dict: dict) -> int:
-    next_str: str = str_dict[
+def next_nop(finch: Finch, str_dict: StrDict) -> int:
+    next_str = str_dict[
         finch.lexome[tinc(finch.inst_h, len(finch.lexome))].to_bytes(1, "big")
     ]
     if next_str == "nop_A":
@@ -43,21 +45,21 @@ def next_nop(finch: Finch, str_dict: dict) -> int:
 
 
 # Instruction No-Ops
-def nop_B(finch: Finch, str_dict: dict) -> None:
+def nop_B(finch: Finch, str_dict: StrDict) -> None:
     finch.inc()
 
 
-def nop_A(finch: Finch, str_dict: dict) -> None:
+def nop_A(finch: Finch, str_dict: StrDict) -> None:
     finch.inc()
 
 
-def nop_C(finch: Finch, str_dict: dict) -> None:
+def nop_C(finch: Finch, str_dict: StrDict) -> None:
     finch.inc()
 
 
-def if_n_equ(finch: Finch, str_dict: dict) -> None:
+def if_n_equ(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     if finch.register[reg] == finch.register[comp(reg)]:
@@ -67,9 +69,9 @@ def if_n_equ(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def if_less(finch: Finch, str_dict: dict) -> None:
+def if_less(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     if finch.register[reg] >= finch.register[comp(reg)]:
@@ -79,28 +81,28 @@ def if_less(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def pop(finch: Finch, str_dict: dict) -> None:
+def pop(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
-    element: bytearray = bytearray((0).to_bytes(4, "big"))
+    element = bytearray((0).to_bytes(4, "big"))
     if finch.stacks[finch.active] != []:
         element = finch.stacks[finch.active][-1]
     finch.register[reg] = element
     finch.inc()
 
 
-def push(finch: Finch, str_dict: dict) -> None:
+def push(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.stacks[finch.active].append(finch.register[reg])
     finch.inc()
 
 
-def swap_stk(finch: Finch, str_dict: dict) -> None:
+def swap_stk(finch: Finch, str_dict: StrDict) -> None:
     if finch.active == 0:
         finch.active = 1
     else:
@@ -108,9 +110,9 @@ def swap_stk(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def swap(finch: Finch, str_dict: dict) -> None:
+def swap(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.register[reg], finch.register[comp(reg)] = (
@@ -120,9 +122,9 @@ def swap(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def shift_r(finch: Finch, str_dict: dict) -> None:
+def shift_r(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.register[reg] = bytearray(
@@ -131,9 +133,9 @@ def shift_r(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def shift_l(finch: Finch, str_dict: dict) -> None:
+def shift_l(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.register[reg] = bytearray(
@@ -142,9 +144,9 @@ def shift_l(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def inc(finch: Finch, str_dict: dict) -> None:
+def inc(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.register[reg] = bytearray(
@@ -153,9 +155,9 @@ def inc(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def dec(finch: Finch, str_dict: dict) -> None:
+def dec(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.register[reg] = bytearray(
@@ -164,9 +166,9 @@ def dec(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def add(finch: Finch, str_dict: dict) -> None:
+def add(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.register[reg] = bytearray(
@@ -176,9 +178,9 @@ def add(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def sub(finch: Finch, str_dict: dict) -> None:
+def sub(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.register[reg] = bytearray(
@@ -190,9 +192,9 @@ def sub(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def xor(finch: Finch, str_dict: dict) -> None:
+def xor(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.register[reg] = bytearray(
@@ -204,9 +206,9 @@ def xor(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def io(finch: Finch, str_dict: dict) -> None:
+def io(finch: Finch, str_dict: StrDict) -> None:
     # ?BX?
-    reg: int = next_nop(finch, str_dict)
+    reg = next_nop(finch, str_dict)
     if reg == 3:
         reg = 1
     finch.output = copy.copy(finch.register[reg])
@@ -214,9 +216,9 @@ def io(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def mov_head(finch: Finch, str_dict: dict) -> None:
+def mov_head(finch: Finch, str_dict: StrDict) -> None:
     # ?IP?
-    head: int = next_nop(finch, str_dict)
+    head = next_nop(finch, str_dict)
     if head == 3:
         head = 0
 
@@ -232,9 +234,9 @@ def mov_head(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def jmp_head(finch: Finch, str_dict: dict) -> None:
+def jmp_head(finch: Finch, str_dict: StrDict) -> None:
     # ?IP?
-    head: int = next_nop(finch, str_dict)
+    head = next_nop(finch, str_dict)
     if head == 3:
         head = 0
 
@@ -250,7 +252,7 @@ def jmp_head(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def get_head(finch: Finch, str_dict: dict) -> None:
+def get_head(finch: Finch, str_dict: StrDict) -> None:
     # ?IP?
     head: int = next_nop(finch, str_dict)
     if head == 3:
@@ -268,25 +270,25 @@ def get_head(finch: Finch, str_dict: dict) -> None:
     finch.inc()
 
 
-def h_alloc(finch: Finch, str_dict: dict) -> None:
+def h_alloc(finch: Finch, str_dict: StrDict) -> None:
     print("h_alloc - unimplemented")
 
 
-def h_divide(finch: Finch, str_dict: dict) -> None:
+def h_divide(finch: Finch, str_dict: StrDict) -> None:
     print("h_divide - unimplemented")
 
 
-def h_copy(finch: Finch, str_dict: dict) -> None:
+def h_copy(finch: Finch, str_dict: StrDict) -> None:
     print("h_copy - unimplemented")
 
 
-def h_search(finch: Finch, str_dict: dict) -> None:
+def h_search(finch: Finch, str_dict: StrDict) -> None:
     print("h_search - unimplemented")
 
 
-def if_label(finch: Finch, str_dict: dict) -> None:
+def if_label(finch: Finch, str_dict: StrDict) -> None:
     print("if_label - unimplemented")
 
 
-def set_flow(finch: Finch, str_dict: dict) -> None:
+def set_flow(finch: Finch, str_dict: StrDict) -> None:
     print("set_flow - unimplemented")
diff --git a/pyfinch/preprocessor.py b/pyfinch/preprocessor.py
index 141c894..260c061 100644
--- a/pyfinch/preprocessor.py
+++ b/pyfinch/preprocessor.py
@@ -2,12 +2,8 @@ from .visual import pretty
 
 
 def pre_process() -> tuple[list[list[str]], list[int], list[str], int]:
-    org_names: list[str] = []
-    org_pops: list[int] = []
-    lexome_name: str = ""
-    orgs: list[list[str]] = []
-    lexome: list[str] = []
-    size: int = 0
+    lexome_name = ""
+    orgs = []
 
     # Parses Config File Once and all at once.
     org_names, org_pops, lexome_name, size = finch_parser("default")
@@ -18,7 +14,7 @@ def pre_process() -> tuple[list[list[str]], list[int], list[str], int]:
         f = open("lexome\{}.cfg".format(lexome_name), "r", encoding="utf-8")
     except:
         pretty("PANIC", "{}.cfg was not found in lexome folder".format(lexome_name))
-    lines: list[str] = f.readlines()
+    lines = f.readlines()
     f.close()
     lexome = lexome_parser(lines)
     pretty("INFO", "Parsed lexome sets")
@@ -36,7 +32,7 @@ def pre_process() -> tuple[list[list[str]], list[int], list[str], int]:
             )
         lines = f.readlines()
         f.close()
-        temp_org: list[str] = org_parser(lines)
+        temp_org = org_parser(lines)
         if len(temp_org) == 0:
             pretty(
                 "WARNING", "There is no lexome for this organism ({})".format(org_name)
@@ -64,11 +60,10 @@ def org_check(lexome_set: list[str], org: list[str]) -> tuple[bool, str | None]:
 
 # Parses organism from lexome file (list of strings)
 def org_parser(ops: list[str]) -> list[str]:
-    o_split: list[str] = []
     org_intermediary: list[str] = []
     for o in ops:
         o_split = o.split("#")
-        first_str: str = o_split[0].strip()
+        first_str = o_split[0].strip()
         if first_str == "":
             continue
         org_intermediary.append(first_str)
@@ -83,7 +78,7 @@ def lexome_parser(ops: list[str]) -> list[str]:
         o_split += o.split(" ")
     o_split = list(map(str.strip, filter(lambda x: x != "\n", o_split)))
     for index, o in enumerate(o_split):
-        is_last: bool = (index + 1) == len(o_split)
+        is_last = (index + 1) == len(o_split)
         if o == "INST":
             if is_last:
                 pretty(
@@ -103,15 +98,15 @@ def lexome_parser(ops: list[str]) -> list[str]:
 def finch_parser(name: str) -> tuple[list[str], list[int], str, int]:
     try:
         with open("config\{}.cfg".format(name), "r", encoding="utf-8") as f:
-            lines: list[str] = f.readlines()
+            lines = f.readlines()
     except:
         pretty("PANIC", "Finch config was not found in config subfolder.")
-    org_names: list[str] = []
-    lexome_name: str = ""
+    org_names = []
+    lexome_name = ""
     org_pops: list[int] = []
-    size: int = -1
+    size = -1
     for row, line in enumerate(lines):
-        entry: list[str] = line.split(" ")
+        entry = line.split(" ")
         if len(entry) == 1 and entry[0] != "\n":
             pretty(
                 "PANIC",
diff --git a/pyfinch/terminal.py b/pyfinch/terminal.py
index 40be03a..dd354b9 100644
--- a/pyfinch/terminal.py
+++ b/pyfinch/terminal.py
@@ -1,4 +1,5 @@
 from . import aviary, bytedict, preprocessor
+from .const import StrDict
 from .visual import pretty
 
 OPTIONS = [
@@ -17,22 +18,18 @@ def main() -> None:
 # Option to run the simulation
 def run_sim() -> None:
     pretty("SPRT", "Starting Pre-Processing & Parsing (IO)")
-    str_orgs: list[list[str]] = [[]]
-    str_lexome: list[str] = []
-    size: int = 0
-    org_pops: list[int] = []
     str_orgs, org_pops, str_lexome, size = preprocessor.pre_process()
 
     # Converts lexemes to binary
-    binary_dict: dict = bytedict.to_dict(str_lexome)
+    binary_dict = bytedict.to_dict(str_lexome)
     # Converts binary to lexemes
-    str_dict: dict = dict(zip(binary_dict.values(), binary_dict.keys()))
+    str_dict = StrDict(dict(zip(binary_dict.values(), binary_dict.keys())))
 
     pretty("SPRT", "Completed Pre-Processing & Parsing (IO)")
 
-    binary_orgs: list[bytearray] = []
+    binary_orgs = []
     # Binary Lexome - will be used for mutation
-    binary_lexome: bytearray = bytedict.translate_to_bytes(str_lexome, binary_dict)
+    binary_lexome = bytedict.translate_to_bytes(str_lexome, binary_dict)
 
     # Read string organisms and translate to binary.
     for o in str_orgs:
@@ -46,8 +43,7 @@ def run_sim() -> None:
 
 # Startup interface
 def runInterface() -> None:
-    buffer: str = ""
-    title_buffer: str = "-" * 23 + "\n"
+    title_buffer = "-" * 23 + "\n"
     title_buffer += "PYFINCH - ALPHA BUILD\n"
     title_buffer += "-" * 23
 
@@ -55,6 +51,7 @@ def runInterface() -> None:
     #   buffer = '\n'.join(
     #                   f"[{i}] {option}" for (i, option, _) in OPTIONS
     #                   )
+    buffer = ""
     for i, option, _ in OPTIONS:
         buffer += f"[{i}] {option}\n"
 
@@ -71,7 +68,7 @@ def runInterface() -> None:
 # Handles the display menus - easily updateable.
 def optionHandler(option: str = None) -> tuple[int, str, str]:
     try:
-        choice: int = int(option)  # type: ignore
+        choice = int(option)  # type: ignore
     except:
         return -1, "NOP", "pass"
 
diff --git a/pyfinch/visual.py b/pyfinch/visual.py
index d629a0d..d0f6357 100644
--- a/pyfinch/visual.py
+++ b/pyfinch/visual.py
@@ -27,4 +27,4 @@ def pretty(type: str, text: str) -> None:
     elif type == "SPRT":
         print(f"{col.OKBLUE}----- {text} -----{col.ENDC}")
     else:
-        print(f'{col.WARNING}[WARNING]{col.ENDC} No pretty format for: {text[:3]} ..."')
+        print(f"{col.WARNING}[WARNING]{col.ENDC} No pretty format for: {text[:3]} ...")
-- 
2.34.1.windows.1

